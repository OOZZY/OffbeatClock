package main;

import processing.core.PApplet;
import processing.core.PConstants;

public class MinuteBranch extends TimeObject {
  float ltheta, rtheta; // angle to branch left, right
  int recursionCount; // current recursion count

  static final int rootBranchLength = 100;

  public MinuteBranch(Main parent) {
    p = parent;
    ltheta = -PConstants.PI/6; // 30 degrees left
    rtheta = PConstants.PI/4; // 45 degrees right
    recursionCount = 0;
  }

  /* Updates this branch. */
  @Override public void update() {
    recursionCount = p.minute%HourTree.maxRecursionCount + 1;
  }

  /* Recursive helper function for draw(). */
  public void branch(float length, float thickness) {
    p.noStroke();

    // p.fill(150, 75, 0); // brown
    // p.fill(0, 255, 0); // green

    // using length and rootBranchLength to dynamically change color of branch.
    // the root branch is the biggest branch and is colored brown.
    // the smaller the branch, the greener the color.
    // the smallest branch is the greenest.
    p.fill(150*length/rootBranchLength, 150-75*length/rootBranchLength, 0);

    p.rect(-thickness/2 ,-length, thickness, length); // branch

    final float shrinkFactor = 0.70f;
    length *= shrinkFactor;
    thickness *= shrinkFactor;

    // variance generated by using Perlin noise value at coordinate
    // determined by second()
    float variance = p.noise(p.second*0.1f)*PConstants.PI/8-PConstants.PI/16;

    // conditionally make recursive calls
    if (length > rootBranchLength * PApplet.pow(shrinkFactor, recursionCount)) {
      // branch left
      p.pushMatrix();
      p.translate(0, -length);
      p.rotate(ltheta + variance);
      branch(length, thickness);
      p.popMatrix();

      // branch right
      p.pushMatrix();
      p.translate(0, -length);
      p.rotate(rtheta + variance);
      branch(length, thickness);
      p.popMatrix();
    }
  }

  /* Draws this branch. */
  @Override public void draw() {
    branch(rootBranchLength, 10);
  }
}
